# SPARQL SELECT queries to compute the placeholders for a given dataset.
placeholders:
  - name: PREDICATE_LARGE_1
    description: A large predicate (with many triples)
    query: |
      SELECT ?p (COUNT(?p) AS ?count) WHERE { ?s ?p ?o }
      GROUP BY ?p ORDER BY DESC(?count)
      LIMIT 1 OFFSET 0
  - name: PREDICATE_LARGE_2
    description: A large predicate, different from the first one
    query: |
      SELECT ?p (COUNT(?p) AS ?count) WHERE { ?s ?p ?o }
      GROUP BY ?p ORDER BY DESC(?count)
      LIMIT 1 OFFSET 1
  - name: PREDICATE_MEDIUM_1
    description: A medium-sized predicate
    query: |
      SELECT ?p (COUNT(?p) AS ?count) WHERE { ?s ?p ?o }
      GROUP BY ?p ORDER BY DESC(?count)
      LIMIT 1 OFFSET 10
  - name: PREDICATE_MEDIUM_2
    description: A medium-sized predicate, different from the first one
    query: |
      SELECT ?p (COUNT(?p) AS ?count) WHERE { ?s ?p ?o }
      GROUP BY ?p ORDER BY DESC(?count)
      LIMIT 1 OFFSET 11
  - name: PREDICATE_SMALL_1
    description: A small predicate
    query: |
      SELECT ?p ?count WHERE {
        { SELECT ?p (COUNT(?p) AS ?count) WHERE { ?s ?p ?o } GROUP BY ?p }
        FILTER (?count <= 1000)
      }
      ORDER BY DESC(?count) LIMIT 1 OFFSET 0
  - name: PREDICATE_SMALL_2
    description: A small predicate
    query: |
      SELECT ?p ?count WHERE {
        { SELECT ?p (COUNT(?p) AS ?count) WHERE { ?s ?p ?o } GROUP BY ?p }
        FILTER (?count <= 1000)
      }
      ORDER BY DESC(?count) LIMIT 1 OFFSET 1
  - name: PREDICATE_LARGE_WITH_LITERAL
    description: A large predicate that has literals as objects
    query: |
      PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
      SELECT (rdfs:label AS ?p) (COUNT(?s) AS ?count)
      WHERE { ?s rdfs:label ?o }

  - name: HAS_RDFS_LABEL
    description: Check if rdfs:label is present
    query: |
      PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
      ASK { ?s rdfs:label ?o }
  - name: HAS_WDT_P31_WDT_P279_STAR
    description: Check if wdt:P31/wdt:P279* is present
    query: |
      PREFIX wdt: <http://www.wikidata.org/prop/direct/>
      ASK { ?s wdt:P31/wdt:P279* ?o }

# The benchmark queries with placeholders.
#
# NOTE: Do not add PREFIX declarations here, they will be added automatically
# by `generate-queries.py` (if the user provides a mean to obtain prefix
# definitions for the dataset).
#
# TODO: more meaningful joins [requires pre-computation of all join sizes]
#
# * two large inputs, large result
# * two large inputs, small result
# * one large input, one small input
# * three large inputs, star, one pair has small result, one has large result
# * three large inputs, star, all pairs have large result
# * three large inputs, line (one sort needed)
# * very many inputs, star (to test the query planner)
# * very many inputs, line 
#
# TODO: more advanced joins
#
# * optional join, payload only, one, few UNDEFs
# * optional join, payload only, one, many UNDEFs
# * optional join, payload only, multiple
# * optional join, fallback for UNDEF, single column
# * optional join, FILTER in optional which connects inner and outer [people and their spouse if born in same year]
# * two-column join [x and y are married and have written a book together]
# * optional two-column join
# * minus join
# * THINK: all the ordinary joins above, where each join can also be optional or minus
#
# TODO: functions
# * Numeric unary functions (e.g., ABS, CEIL, FLOOR, ROUND)
# * Numeric binary functions (e.g., +, -, *, /)
# * String functions (e.g., STRLEN, SUBSTR, UCASE, LCASE)
# * Date functions (e.g., NOW, YEAR, MONTH, DAY)
# * Variadic functions (e.g., IF, COALESCE, CONCAT) 
# * Expression with one function [chunked might make a difference]
# * Expression with many functions [tests chunked vs. entry by entry evaluation]
# * TODO: How to measure the time for the functions minus the time for computing the input?
# * TODO: Find simple query, where the function or expression is the bottleneck
# * IDEA: generate large inputs via VALUES (with Cartesian product) and BIND
#
# TODO: property paths
# * <pred>+, with/without left or right side bound 
# * <pred1>/<pred2> nothing special, just a join
# * property paths involving the empty path   ?x <p>* ?y 
# * wdt:P31/wdt:P279*, with/without left or right side bound [dataset specific]
#
# TODO: UNIONs
# * UNION of two, outside is very constraining [multiplication is essential]
# * UNION of two, outside is not very constraining
# * join of UNIONs [(a + b) * (c + d)], should avoid the sort
#
# TODO: Which engines
# * QLever
# * MilleniumDB [research prototype]
# * GraphDB [good commercial representative]
# * Fuseki [Java, standard-complete, slow]
# * Virtuoso [quick and dirty]
# * Oxigraph [Rust, upcoming]
#
# TODO: index scans with FILTER with contiguous range [realhannes stuff]
queries:
  # JOIN queries.
  - name: single-join-medium
    description: JOIN of two medium-sized predicates
    group: join
    query: |
      SELECT ?s ?o1 ?o2
      WHERE { ?s %PREDICATE_MEDIUM_1% ?o1 . ?s %PREDICATE_MEDIUM_2% ?o2 }
  - name: single-join-small-large
    description: JOIN of a small and a large predicate
    group: join
    query: |
      SELECT ?s ?o1 ?o2
      WHERE { ?s %PREDICATE_SMALL_1% ?o1 . ?s %PREDICATE_LARGE_1% ?o2 }
  - name: single-join-medium-large
    description: JOIN of a medium-sized and a large predicate
    group: join
    query: |
      SELECT ?s ?o1 ?o2
      WHERE { ?s %PREDICATE_MEDIUM_1% ?o1 . ?s %PREDICATE_LARGE_1% ?o2 }
  - name: single-join-large
    description: JOIN of two large predicates
    group: join
    query: |
      SELECT ?s ?o1 ?o2
      WHERE { ?s %PREDICATE_LARGE_1% ?o1 . ?s %PREDICATE_LARGE_2% ?o2 }

  # GROUP BY queries.
  - name: group-by-count-object-small
    description: GROUP_BY with COUNT, for object of large predicate
    group: group-by
    query: |
      SELECT ?object (COUNT(?object) AS ?count)
      WHERE { ?subject %PREDICATE_SMALL_1% ?object }
      GROUP BY ?object ORDER BY DESC(?count)
  - name: group-by-count-object-medium
    description: GROUP_BY with COUNT, for object of large predicate
    group: group-by
    query: |
      SELECT ?object (COUNT(?object) AS ?count)
      WHERE { ?subject %PREDICATE_MEDIUM_1% ?object }
      GROUP BY ?object ORDER BY DESC(?count)
  - name: group-by-count-object-large
    description: GROUP_BY with COUNT, for object of large predicate
    group: group-by
    query: |
      SELECT ?object (COUNT(?object) AS ?count)
      WHERE { ?subject %PREDICATE_LARGE_1% ?object }
      GROUP BY ?object ORDER BY DESC(?count)
  - name: group-by-count-subject-large
    description: GROUP_BY with COUNT, for subject of large predicate
    group: group-by
    query:
      SELECT ?subject (COUNT(?subject) AS ?count)
      WHERE { ?subject %PREDICATE_LARGE_1% ?object }
      GROUP BY ?subject ORDER BY DESC(?count)

  # PROPERTY_PATH queries.
  - name: wdt-P31-wdt-P279-star
    description: Subjects with their wdt:P31/wdt:P279* type
    group: property-path
    condition: HAS_WDT_P31_WDT_P279_STAR
    query: |
      SELECT ?s ?o WHERE { ?s %PREDICATE_LARGE_1% ?o }

  # REGEX queries.
  - name: regex-3-contains
    description: CONTAINS filter with fixed string of length 3
    group: range-filter
    condition: HAS_RDFS_LABEL
    query: |
      SELECT ?s ?o
      WHERE { ?s %PREDICATE_LARGE_WITH_LITERAL% ?o FILTER CONTAINS(?o, "com") }
  - name: regex-3-fixed
    description: REGEX filter with fixed string of length 3
    group: range-filter
    condition: HAS_RDFS_LABEL
    query: |
      SELECT ?s ?o
      WHERE { ?s %PREDICATE_LARGE_WITH_LITERAL% ?o FILTER REGEX(?o, "com") }
  - name: regex-3
    description: REGEX filter with expression of length 3
    group: range-filter
    condition: HAS_RDFS_LABEL
    query: |
      SELECT ?s ?o
      WHERE { ?s %PREDICATE_LARGE_WITH_LITERAL% ?o FILTER REGEX(?o, "c.m") }
  - name: regex-prefix-1
    description: REGEX filter with prefix of length 1
    group: range-filter
    condition: HAS_RDFS_LABEL
    query: |
      SELECT ?s ?o
      WHERE { ?s %PREDICATE_LARGE_WITH_LITERAL% ?o FILTER REGEX(?o, "^C") }
  - name: regex-prefix-2
    description: REGEX filter with prefix of length 2
    condition: HAS_RDFS_LABEL
    group: range-filter
    query: |
      SELECT ?s ?o
      WHERE { ?s %PREDICATE_LARGE_WITH_LITERAL% ?object FILTER REGEX(?object, "^Co") }
  - name: regex-prefix-3
    description: REGEX filter with prefix of length 3
    condition: HAS_RDFS_LABEL
    group: range-filter
    query: |
      SELECT ?s ?o
      WHERE { ?s %PREDICATE_LARGE_WITH_LITERAL% ?object FILTER REGEX(?object, "^Com") }

  # SIZE MATTERS queries.
  - name: result-size-small
    description: A small predicate
    group: result-size
    query: |
      SELECT ?s ?o WHERE { ?s %PREDICATE_SMALL_1% ?o }
  - name: result-size-medium
    description: A medium-sized predicate
    group: result-size
    query: |
      SELECT ?s ?o WHERE { ?s %PREDICATE_MEDIUM_1% ?o }
  - name: result-size-large
    description: A large predicate
    group: result-size
    query: |
      SELECT ?s ?o WHERE { ?s %PREDICATE_LARGE_1% ?o }

  # STATISTICS queries.
  - name: number-of-triples
    description: Total number of triples
    group: statistics
    query: SELECT (COUNT(?s) AS ?count) WHERE { ?s ?p ?o }
  - name: number-of-subjects
    description: Total number of distinct subjects
    group: statistics
    query: SELECT (COUNT(DISTINCT ?s) AS ?count) WHERE { ?s ?p ?o }
  - name: number-of-predicates
    description: Total number of distinct predicates
    group: statistics
    query: SELECT (COUNT(DISTINCT ?p) AS ?count) WHERE { ?s ?p ?o }
  - name: number-of-objects
    description: Total number of distinct objects
    group: statistics
    query: SELECT (COUNT(DISTINCT ?o) AS ?count) WHERE { ?s ?p ?o }
  - name: number-of-literals
    description: Total number of literals
    group: statistics
    query: SELECT (COUNT(?o) AS ?count) WHERE { ?s ?p ?o FILTER ISLITERAL(?o) }
  - name: number-of-blank-nodes
    description: Total number of blank nodes
    group: statistics
    query: SELECT (COUNT(?s) AS ?count) WHERE { ?s ?p ?o FILTER ISBLANK(?s) }

  # TODO: add queries
  # ORDER BY
  # * large predicate + order by
  #
  # JOINS
  # * join large predicates, small result
  # * join large predicates, medium result
  # * join large predicates, large result
  # * star joins
  # * chain joins
  #
  # SPECIAL JOINS
  # * optional join
  # * minus join
  # * multi-column join
  # * union
  #
  # LANGUAGE FILTER
  # * rdfs:label und FILTER(LANG(?o) = "en")
  # * rdfs:label und FILTER(LANGMATCHES(LANG(?o), "en"))
  # * rdfs:label und FILTER(LANG(?o) != "en")  [no optimization]
  # * rdfs:label und FILTER(LANG(?o) IN ("en", "de"))
  #
  # EXPRESSIONS
  # * Large predicate with binary FILTER expression
  # * All sorts of functions
  #
  # GRAPHS
  # * check that graph filters work efficiently
  #
  #
  # SELECT ?p1 ?p2 (COUNT(?m) AS ?count) WHERE {
  #   ?s ?p1 ?m .
  #   ?m ?p2 ?o .
  # }
  # GROUP BY ?p1 ?p2
  # ORDER BY DESC(?count)
  #
