# SPARQL queries to gain insight on the characteristics of the knowledge graph,
# used to generate placeholders in the next step.
precomputed_queries:
  - name: PREDICATE_SIZE_QUERY
    query: |
      SELECT ?p (COUNT(?p) AS ?count) WHERE { ?s ?p ?o }
      GROUP BY ?p ORDER BY DESC(?count)
    cache_result: false
  - name: PREDICATE_SIZE_SMALL_QUERY
    query: |
      SELECT ?p ?count WHERE {
        { SELECT ?p (COUNT(?p) AS ?count) WHERE { ?s ?p ?o } GROUP BY ?p }
        FILTER (?count <= 1000)
      } ORDER BY DESC(?count)
  - name: PREDICATE_LARGE_WITH_NUMERIC_QUERY
    query: |
      SELECT ?p (COUNT(?p) AS ?count) WHERE { ?s ?p ?o FILTER ISNUMERIC(?o) }
      GROUP BY ?p ORDER BY DESC(?count)
    cache_result: true
  - name: JOIN_ON_SUBJECT_SIZE_QUERY
    query: |
      SELECT * {
        { SELECT ?p1 ?p2 (SUM(?cnt1 * ?cnt2) as ?count_join) WHERE {
          { SELECT ?a ?p1 (COUNT(?a) as ?cnt1) { ?a ?p1 ?o . } GROUP BY ?a ?p1 }
          { SELECT ?a ?p2 (COUNT(?a) as ?cnt2) { ?a ?p2 ?o . } GROUP BY ?a ?p2 }
          FILTER(?p1 != ?p2)
        } GROUP BY ?p1 ?p2 }
        { SELECT ?p1 (COUNT(?p1) AS ?count_p1) { ?a ?p1 ?o } GROUP BY ?p1 }
        { SELECT ?p2 (COUNT(?p2) AS ?count_p2) { ?a ?p2 ?o } GROUP BY ?p2 }
      } ORDER BY DESC(?count_join)
    cache_result: true
  - name: JOIN_DIAGONAL_SIZE_QUERY
    query: |
      SELECT * {
        { SELECT ?p1 ?p2 (SUM(?cnt1 * ?cnt2) as ?count_join) WHERE {
          { SELECT ?m ?p1 (COUNT(?m) as ?cnt1) { ?s ?p1 ?m . } GROUP BY ?m ?p1 }
          { SELECT ?m ?p2 (COUNT(?m) as ?cnt2) { ?m ?p2 ?o . } GROUP BY ?m ?p2 }
          FILTER(?p1 != ?p2)
        } GROUP BY ?p1 ?p2 }
        { SELECT ?p1 (COUNT(?p1) AS ?count_p1) { ?a ?p1 ?o } GROUP BY ?p1 }
        { SELECT ?p2 (COUNT(?p2) AS ?count_p2) { ?a ?p2 ?o } GROUP BY ?p2 }
      } ORDER BY DESC(?count_join)
    cache_result: true
  - name: JOIN_ON_OBJECT_SIZE_QUERY
    query: |
      SELECT * {
        {SELECT ?p1 ?p2 (SUM(?cnt1 * ?cnt2) as ?count_join) WHERE {
          { SELECT ?p1 ?o (COUNT(?o) as ?cnt1) { ?s ?p1 ?o . } GROUP BY ?o ?p1 }
          { SELECT ?p2 ?o (COUNT(?o) as ?cnt2) { ?s ?p2 ?o . } GROUP BY ?o ?p2 }
          FILTER(?p1 != ?p2)
        } GROUP BY ?p1 ?p2 }
        { SELECT ?p1 (COUNT(?p1) AS ?count_p1) { ?a ?p1 ?o } GROUP BY ?p1 }
        { SELECT ?p2 (COUNT(?p2) AS ?count_p2) { ?a ?p2 ?o } GROUP BY ?p2 }
      } ORDER BY DESC(?count_join)
    cache_result: true
  - name: MULTIPLICITY_ON_OBJECT_QUERY
    query: |
      SELECT ?p (SUM(?count_s) AS ?count) (COUNT(?p) AS ?count_distinct)
        (?count / ?count_distinct AS ?multiplicity) WHERE {
        SELECT ?p ?x (COUNT(?s) AS ?count_s) WHERE { ?s ?p ?x } GROUP BY ?p ?x }
      GROUP BY ?p ORDER BY DESC(?multiplicity)
    cache_result: true
  - name: TRANSITIVE_PATH_PREDICATES_QUERY
    query: |
      SELECT ?p1 ?count_p1 ?count ((?count / ?count_p1) AS ?x) WHERE {
        { SELECT ?p1 (COUNT(*) AS ?count) WHERE {
          ?s ?p1 ?m . ?m ?p2 ?o . FILTER(?p1 = ?p2) } GROUP BY ?p1}
        { SELECT ?p1 (COUNT(?p1) AS ?count_p1) { ?a ?p1 ?o } GROUP BY ?p1 }
      } ORDER BY DESC(?x) 
    cache_result: true

# SPARQL SELECT queries to compute the placeholders for a given dataset.
placeholders:
  # Single predicates of various sizes
  - name: PREDICATE_LARGE_1
    description: A large predicate (with many triples)
    query: |
      SELECT ?p ?count { %PREDICATE_SIZE_QUERY% } LIMIT 1
  - name: PREDICATE_LARGE_2
    description: A large predicate, different from the first one
    query: |
      SELECT ?p ?count { %PREDICATE_SIZE_QUERY% } LIMIT 1 OFFSET 1
  - name: PREDICATE_MEDIUM_1
    description: A medium-sized predicate
    query: |
      SELECT ?p ?count { %PREDICATE_SIZE_QUERY% } LIMIT 1 OFFSET 10
  - name: PREDICATE_MEDIUM_2
    description: A medium-sized predicate, different from the first one
    query: |
      SELECT ?p ?count { %PREDICATE_SIZE_QUERY% } LIMIT 1 OFFSET 11
  - name: PREDICATE_SMALL_1
    description: A small predicate
    query: |
      SELECT ?p ?count { %PREDICATE_SIZE_SMALL_QUERY% } LIMIT 1
  - name: PREDICATE_SMALL_2
    description: A small predicate
    query: |
      SELECT ?p ?count { %PREDICATE_SIZE_SMALL_QUERY% } LIMIT 1 OFFSET 1

  # Predicates for certain datatypes
  - name: PREDICATE_LARGE_WITH_LITERAL
    description: A large predicate that has literals as objects
    query: |
      PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
      SELECT (rdfs:label AS ?p) (COUNT(?s) AS ?count)
      WHERE { ?s rdfs:label ?o }
  - name: PREDICATE_LARGE_WITH_NUMERIC
    description: A large predicate that has numeric literals as objects
    query: |
      SELECT * { %PREDICATE_LARGE_WITH_NUMERIC_QUERY% } LIMIT 1
  - name: AVG_PREDICATE_LARGE_WITH_NUMERIC
    description: todo
    query: |
      SELECT (AVG(?o) AS ?avg) {
        { SELECT * { %PREDICATE_LARGE_WITH_NUMERIC_QUERY% } LIMIT 1 }
        ?s ?p ?o .
      } GROUP BY ?p
  - name: PREDICATE_LARGE_WITH_DATE
    description: A large predicate that has date literals as objects
    query: |
      PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
      SELECT ?p (COUNT(?p) AS ?count)
      WHERE { ?s ?p ?o FILTER (?o >= "-9999-01-01"^^xsd:date && ?o <= "9999-12-31"^^xsd:date) }
      GROUP BY ?p ORDER BY DESC(?count)
      LIMIT 1

  # Predicates for subject join of two large predicate with large result
  - name: PREDICATE_1_FOR_LARGE_SUBJ_JOIN
    description: Predicate 1 for subject joinn of two large predicates with large result
    query: |
      SELECT ?p1 ?count_p1 { %JOIN_ON_SUBJECT_SIZE_QUERY% }
      ORDER BY DESC(?count_join) LIMIT 1
  - name: PREDICATE_2_FOR_LARGE_SUBJ_JOIN
    description: Predicate 2 for subject join of two large predicates with large result
    query: |
      SELECT ?p2 ?count_p2 { %JOIN_ON_SUBJECT_SIZE_QUERY% }
      ORDER BY DESC(?count_join) LIMIT 1

  # Predicates for subject join with one small predicate and large result
  - name: SMALL_PREDICATE_1_FOR_SUBJ_JOIN
    description: Predicate 1 for subject join with one small predicate and large result
    query: |
      SELECT ?p1 ?count_p1 {
        %JOIN_ON_SUBJECT_SIZE_QUERY% 
        FILTER(?count_p1 <= 1000)
      } ORDER BY DESC(?count_join) LIMIT 1
  - name: LARGE_PREDICATE_2_FOR_SUBJ_JOIN
    description: Predicate 2 for subject join with one small predicate and large result
    query: |
      SELECT ?p2 ?count_p2 {
        %JOIN_ON_SUBJECT_SIZE_QUERY% 
        FILTER(?count_p1 <= 1000)
      } ORDER BY DESC(?count_join) LIMIT 1

  # Prdicates for subject join with two small predicates and large result
  - name: SMALL_PREDICATE_1_FOR_SUBJ_JOIN_2
    description: Predicate 1 for subject join with two small predicates and large result
    query: |
      SELECT ?p1 ?count_p1 {
        %JOIN_ON_SUBJECT_SIZE_QUERY% 
        FILTER(?count_p1 <= 1000 && ?count_p2 <= 1000)
      } ORDER BY DESC(?count_join) LIMIT 1
  - name: SMALL_PREDICATE_2_FOR_SUBJ_JOIN_2
    description: Predicate 2 for subject join with two small predicates and large result
    query: |
      SELECT ?p2 ?count_p2 {
        %JOIN_ON_SUBJECT_SIZE_QUERY% 
        FILTER(?count_p1 <= 1000 && ?count_p2 <= 1000)
      } ORDER BY DESC(?count_join) LIMIT 1

  # Star subject join with larges sum of join sizes
  - name: PREDICATE_3_FOR_SUBJ_STAR_JOIN
    description: Star subject join with larges sum of join sizes
    query: |
      SELECT ?p4 ?count_p4 {
        { SELECT * WHERE { %JOIN_ON_SUBJECT_SIZE_QUERY% } LIMIT 1000 }
        { SELECT (?p3 AS ?p2) ?p4 ?count_p4 ?count_join2 {
        { SELECT (?p1 AS ?p3) (?count_p1 AS ?count_p3) (?p2 AS ?p4)
          (?count_p2 AS ?count_p4) (?count_join AS ?count_join2) {
          %JOIN_ON_SUBJECT_SIZE_QUERY% } LIMIT 1000 }
        } }
        FILTER(?p2 = ?p3 && ?p1 != ?p4)
      } ORDER BY DESC(?count_join + ?count_join2) LIMIT 1

  # Subject and diagonal join with largest sum of join sizes
  - name: PREDICATE_3_FOR_LARGE_CHAIN_JOIN
    description: Subject and diagonal join with larges sum of join sizes
    query: |
      SELECT ?p4 ?count_p4 {
        { SELECT * WHERE { %JOIN_ON_SUBJECT_SIZE_QUERY% } LIMIT 1000 }
        { SELECT (?p3 AS ?p2) ?p4 ?count_p4 ?count_join2 {
          { SELECT (?p1 AS ?p3) (?count_p1 AS ?count_p3) (?p2 AS ?p4)
          (?count_p2 AS ?count_p4) (?count_join AS ?count_join2) {
          %JOIN_DIAGONAL_SIZE_QUERY% } LIMIT 1000 }
        } }
      } ORDER BY DESC(?count_join + ?count_join2) LIMIT 1

  # Boolean checks
  - name: HAS_RDFS_LABEL
    description: Check if rdfs:label is present
    query: |
      PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
      ASK { ?s rdfs:label ?o }
  - name: HAS_WDT_P31_WDT_P279_STAR
    description: Check if wdt:P31/wdt:P279* is present
    query: |
      PREFIX wdt: <http://www.wikidata.org/prop/direct/>
      ASK { ?s wdt:P31/wdt:P279* ?o }
  
  # Predicate with low and high multiplicity
  - name: PREDICATE_LOW_MULTIPLICITY
    description: todo
    query: |
      SELECT ?p ?count ?count_distinct ?multiplicity {
        %MULTIPLICITY_ON_OBJECT_QUERY% } ORDER BY DESC(?count_distinct) LIMIT 1
  - name: PREDICATE_HIGH_MULTIPLICITY
    description: todo
    query: |
      SELECT ?p ?count ?count_distinct ?multiplicity {
        %MULTIPLICITY_ON_OBJECT_QUERY% } ORDER BY DESC(?multiplicity) LIMIT 1
  
  - name: LARGE_PREDICATE_1_FOR_GROUP_BY
    description: todo
    query: |
      SELECT ?p1 (?count_join / ?count_distinct AS ?order) {
        %JOIN_ON_SUBJECT_SIZE_QUERY%
        { SELECT (?p AS ?p1) ?count_distinct ?multiplicity {
          %MULTIPLICITY_ON_OBJECT_QUERY%
        } }
      } ORDER BY DESC(?order) LIMIT 1
  - name: LARGE_PREDICATE_2_FOR_GROUP_BY
    description: todo
    query: |
      SELECT ?p2 (?count_join / ?count_distinct AS ?order) {
        %JOIN_ON_SUBJECT_SIZE_QUERY%
        { SELECT (?p AS ?p1) ?count_distinct ?multiplicity {
          %MULTIPLICITY_ON_OBJECT_QUERY%
        } }
      } ORDER BY DESC(?order) LIMIT 1


  # For filter (use with multiplicity predicates)
  # - name: FILTER_OUT_MANY_VALUES
  #   description: todo
  #   query: |
  #     SELECT ?o (COUNT(?o) AS ?count) WHERE {
  #       ?s %PREDICATE_HIGH_MULTIPLICITY% ?o }
  #     GROUP BY ?o ORDER BY DESC(?count) LIMIT 1
  # - name: FILTER_OUT_FEW_VALUES
  #   description: todo
  #   query: |
  #     SELECT ?o (COUNT(?o) AS ?count) WHERE {
  #       ?s %PREDICATE_LOW_MULTIPLICITY% ?o }
  #     GROUP BY ?o ORDER BY ASC(?count) LIMIT 1

  #
  - name: PREDICATE_TRANSITIVE_PATH
    description: todo
    query: |
      SELECT * { %TRANSITIVE_PATH_PREDICATES_QUERY% } LIMIT 1

# The benchmark queries with placeholders.
#
# NOTE: Do not add PREFIX declarations here, they will be added automatically
# by `generate-queries.py` (if the user provides a mean to obtain prefix
# definitions for the dataset).
#
# TODO: more meaningful joins [requires pre-computation of all join sizes]
#
# * two large inputs, large result
# * two large inputs, small result
# * one large input, one small input
# * three large inputs, star, one pair has small result, one has large result
# * three large inputs, star, all pairs have large result
# * three large inputs, line (one sort needed)
# * very many inputs, star (to test the query planner)
# * very many inputs, line 
#
# TODO: more advanced joins
#
# * optional join, payload only, one, few UNDEFs
# * optional join, payload only, one, many UNDEFs
# * optional join, payload only, multiple
# * optional join, fallback for UNDEF, single column
# * optional join, FILTER in optional which connects inner and outer [people and their spouse if born in same year]
# * two-column join [x and y are married and have written a book together]
# * optional two-column join
# * minus join
# * THINK: all the ordinary joins above, where each join can also be optional or minus
#
# TODO: functions
# * Numeric unary functions (e.g., ABS, CEIL, FLOOR, ROUND)
# * Numeric binary functions (e.g., +, -, *, /)
# * String functions (e.g., STRLEN, SUBSTR, UCASE, LCASE)
# * Date functions (e.g., NOW, YEAR, MONTH, DAY)
# * Variadic functions (e.g., IF, COALESCE, CONCAT) 
# * Expression with one function [chunked might make a difference]
# * Expression with many functions [tests chunked vs. entry by entry evaluation]
# * TODO: How to measure the time for the functions minus the time for computing the input?
# * TODO: Find simple query, where the function or expression is the bottleneck
# * IDEA: generate large inputs via VALUES (with Cartesian product) and BIND
#
# TODO: property paths
# * <pred>+, with/without left or right side bound 
# * <pred1>/<pred2> nothing special, just a join
# * property paths involving the empty path   ?x <p>* ?y 
# * wdt:P31/wdt:P279*, with/without left or right side bound [dataset specific]
#
# TODO: UNIONs
# * UNION of two, outside is very constraining [multiplication is essential]
# * UNION of two, outside is not very constraining
# * join of UNIONs [(a + b) * (c + d)], should avoid the sort
#
# TODO: Which engines
# * QLever
# * MilleniumDB [research prototype]
# * GraphDB [good commercial representative]
# * Fuseki [Java, standard-complete, slow]
# * Virtuoso [quick and dirty]
# * Oxigraph [Rust, upcoming]
#
# TODO: index scans with FILTER with contiguous range [realhannes stuff]
queries:
  # JOIN of two triple patterns
  - name: join-2-small-large
    description: JOIN of a small and a large predicate
    group: join
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_SMALL_1% ?o1 . ?s %PREDICATE_LARGE_1% ?o2 }
  - name: join-2-large-small
    description: JOIN of a large and a small predicate
    group: join
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_1% ?o1 . ?s %PREDICATE_SMALL_1% ?o2 }
  - name: join-2-large-large
    description: JOIN of two large predicates
    group: join
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_1% ?o1 . ?s %PREDICATE_LARGE_2% ?o2 }
  - name: join-2-large-large-with-large-result
    description: JOIN of two large predicates with a large result
    group: join
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE {
        ?s %PREDICATE_1_FOR_LARGE_SUBJ_JOIN% ?o1 .
        ?s %PREDICATE_2_FOR_LARGE_SUBJ_JOIN% ?o2 }
  - name: join-2-small-small-with-large-result
    description: JOIN of two small predicates
    group: join
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE {
        ?s %SMALL_PREDICATE_1_FOR_SUBJ_JOIN_2% ?o1 .
        ?s %SMALL_PREDICATE_2_FOR_SUBJ_JOIN_2% ?o2 }

  # JOIN of three triple patterns
  - name: join-3-star-largest-sum-of-join-sizes
    description: JOIN star of three large predicates with the largest sum of join sizes
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE {
        ?s %PREDICATE_1_FOR_LARGE_SUBJ_JOIN% ?o1 .
        ?s %PREDICATE_2_FOR_LARGE_SUBJ_JOIN% ?o2 .
        ?s %PREDICATE_3_FOR_SUBJ_STAR_JOIN% ?o3 .
      }
  - name: join-3-chain-largest-sum-of-join-sizes
    description: JOIN chain of three large predicates with the largest sum of join sizes
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE {
        ?s1 %PREDICATE_1_FOR_LARGE_SUBJ_JOIN% ?o1 .
        ?s1 %PREDICATE_2_FOR_LARGE_SUBJ_JOIN% ?m .
        ?m %PREDICATE_3_FOR_LARGE_CHAIN_JOIN% ?o2 .
      }

  # OPTIONAL JOIN queries.
  - name: optional-join-small-large
    description: OPTIONAL JOIN of a small and a large predicate
    group: optional-join
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_SMALL_1% ?o1 OPTIONAL { ?s %PREDICATE_LARGE_1% ?o2 } }
  - name: optional-join-large-small
    description: OPTIONAL JOIN of a large and a small predicate
    group: optional-join
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_1% ?o1 OPTIONAL { ?s %PREDICATE_SMALL_1% ?o2 } }
  - name: optional-join-large-large
    description: OPTIONAL JOIN of two large predicates
    group: optional-join
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_1% ?o1 OPTIONAL { ?s %PREDICATE_LARGE_2% ?o2 } }

  # MINUS JOIN queries.
  - name: minus-join-small-large
    description: MINUS JOIN of a small and a large predicate
    group: minus-join
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_SMALL_1% ?o1 MINUS { ?s %PREDICATE_LARGE_1% ?o2 } }
  - name: minus-join-large-small
    description: MINUS JOIN of a large and a small predicate
    group: minus-join
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_1% ?o1 MINUS { ?s %PREDICATE_SMALL_1% ?o2 } }
  - name: minus-join-large-large
    description: MINUS JOIN of two large predicates
    group: minus-join
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_1% ?o1 MINUS { ?s %PREDICATE_LARGE_2% ?o2 } }

  # EXIST JOIN queries.
  - name: exists-join-small-large
    description: EXISTS JOIN of a small and a large predicate
    group: exists-join
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_SMALL_1% ?o1 FILTER EXISTS { ?s %PREDICATE_LARGE_1% ?o2 } }
  - name: exists-join-large-small
    description: EXISTS JOIN of a large and a small predicate
    group: exists-join
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_1% ?o1 FILTER EXISTS { ?s %PREDICATE_SMALL_1% ?o2 } }
  - name: exists-join-large-large
    description: EXISTS JOIN of two large predicates
    group: exists-join
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_1% ?o1 FILTER EXISTS { ?s %PREDICATE_LARGE_2% ?o2 } }

  # UNION queries.
  - name: union-no-constraint
    description: UNION of two large predicates, no constraint
    group: union
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { { ?s %PREDICATE_LARGE_1% ?o } UNION { ?s %PREDICATE_LARGE_1% ?o } }
  - name: union-constraint-small-join
    description: UNION of two large predicates, constraint by small predicate
    group: union
    query: |
      SELECT (COUNT(*) AS ?count) WHERE {
        { ?s %PREDICATE_LARGE_1% ?o1 } UNION { ?s %PREDICATE_LARGE_1% ?o1 }
        ?s %PREDICATE_SMALL_1% ?o2
      }
  - name: union-constraint-large-join
    description: UNION of two large predicates, constraint by large predicate
    group: union
    query: |
      SELECT (COUNT(*) AS ?count) WHERE {
        { ?s %PREDICATE_LARGE_1% ?o1 } UNION { ?s %PREDICATE_LARGE_1% ?o1 }
        ?s %PREDICATE_LARGE_2% ?o2
      }
  - name: union-constraint-filter-restrictive
    description: UNION of two large predicates, constraint by restrictive FILTER
    group: union
    query: |
      SELECT (COUNT(*) AS ?count) WHERE {
        { ?s %PREDICATE_LARGE_1% ?o } UNION { ?s %PREDICATE_LARGE_1% ?o }
        FILTER (?s = ?o)
      }

  # MULTICOLUMN JOIN queries.
  - name: multicolumn-join-small-large
    description: Multicolumn JOIN of a small and a large predicate
    group: multicolumn-join
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_SMALL_1% ?o . ?s %PREDICATE_LARGE_1% ?o }
  - name: multicolumn-join-large-small
    description: Multicolumn JOIN of a large and a small predicate
    group: multicolumn-join
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_1% ?o . ?s %PREDICATE_SMALL_1% ?o }
  - name: multicolumn-join-large-large
    description: Multicolumn JOIN of two large predicates
    group: multicolumn-join
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_1% ?o . ?s %PREDICATE_LARGE_2% ?o }

  # GROUP BY queries.
  - name: group-by-count-subject-large-predicate
    description: GROUP BY with COUNT, for subject of large predicate
    group: group-by
    query: |
      SELECT ?subject (COUNT(?subject) AS ?count)
      WHERE { ?subject %PREDICATE_LARGE_1% ?object }
      GROUP BY ?subject ORDER BY DESC(?count)
      LIMIT %LIMIT%
  - name: group-by-count-object-large-predicate
    description: GROUP BY with COUNT, for object of large predicate
    group: group-by
    query: |
      SELECT ?object (COUNT(?object) AS ?count)
      WHERE { ?subject %PREDICATE_LARGE_1% ?object }
      GROUP BY ?object ORDER BY DESC(?count)
      LIMIT %LIMIT%
  - name: group-by-count-object-high-multiplicity
    description: GROUP BY with COUNT, for object with high multiplicity
    group: group-by
    query: |
      SELECT ?object (COUNT(?subject) AS ?count) {
      ?subject %PREDICATE_HIGH_MULTIPLICITY% ?object .
      } GROUP BY ?object ORDER BY DESC(?count) LIMIT %LIMIT%
  - name: group-by-count-object-low-multiplicity
    description: GROUP BY with COUNT, for object with low multiplicity
    group: group-by
    query: |
      SELECT ?object (COUNT(?subject) AS ?count) {
      ?subject %PREDICATE_LOW_MULTIPLICITY% ?object .
      } GROUP BY ?object ORDER BY DESC(?count) LIMIT %LIMIT%
  - name: group-by-count-object-wrong-sort-order
    description: GROUP BY with COUNT, for object but not sorted by object
    group: group-by
    query: |
      SELECT ?o1 (COUNT(?s) AS ?count) {
        ?s %LARGE_PREDICATE_1_FOR_GROUP_BY% ?o1 .
        ?s %LARGE_PREDICATE_2_FOR_GROUP_BY% ?o2 .
      } GROUP BY ?o1 ORDER BY DESC(?count) LIMIT %LIMIT%
  - name: group-by-complex-aggregate
    description: GROUP BY with COUNT and MIN and MAX and SAMPLE
    group: group-by
    query: |
      SELECT ?o1 (COUNT(?s) AS ?count) (MIN(?s) AS ?min) (MAX(?s) AS ?max)
        (SAMPLE(?s) AS ?sample) {
        ?s %LARGE_PREDICATE_1_FOR_GROUP_BY% ?o1 .
        ?s %LARGE_PREDICATE_2_FOR_GROUP_BY% ?o2 .
      } GROUP BY ?o1 ORDER BY DESC(?count) LIMIT %LIMIT%

  # PROPERTY_PATH queries.
  - name: wdt-P31-wdt-P279-star
    description: Subjects with their wdt:P31/wdt:P279* type
    group: property-path
    condition: HAS_WDT_P31_WDT_P279_STAR
    query: |
      SELECT ?s ?o WHERE { ?s wdt:P31/wdt:P279* ?o }
      LIMIT %LIMIT%
  - name: transitive-path-plus
    description: Transitive path with plus
    query: |
      SELECT (COUNT(*) AS ?count) { ?s %PREDICATE_TRANSITIVE_PATH%+ ?o }

  # REGEX queries.
  - name: regex-3-contains
    description: CONTAINS filter with fixed string of length 3
    group: range-filter
    condition: HAS_RDFS_LABEL
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_WITH_LITERAL% ?o FILTER CONTAINS(?o, "com") }
  - name: regex-3-fixed
    description: REGEX filter with fixed string of length 3
    group: range-filter
    condition: HAS_RDFS_LABEL
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_WITH_LITERAL% ?o FILTER REGEX(?o, "com") }
  - name: regex-3
    description: REGEX filter with expression of length 3
    group: range-filter
    condition: HAS_RDFS_LABEL
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_WITH_LITERAL% ?o FILTER REGEX(?o, "c.m") }
  - name: regex-prefix-1
    description: REGEX filter with prefix of length 1
    group: range-filter
    condition: HAS_RDFS_LABEL
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_WITH_LITERAL% ?o FILTER REGEX(?o, "^C") }
  - name: regex-prefix-2
    description: REGEX filter with prefix of length 2
    condition: HAS_RDFS_LABEL
    group: range-filter
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_WITH_LITERAL% ?object FILTER REGEX(?object, "^Co") }
  - name: regex-prefix-3
    description: REGEX filter with prefix of length 3
    condition: HAS_RDFS_LABEL
    group: range-filter
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_WITH_LITERAL% ?object FILTER REGEX(?object, "^Com") }

  # SIZE MATTERS queries.
  - name: result-size-tiny
    description: Export 10 tuples
    group: result-size
    query: |
      SELECT ?s ?o
      WHERE { ?s %PREDICATE_LARGE_1% ?o }
      LIMIT 10
  - name: result-size-small
    description: Export 1000 tuples
    group: result-size
    query: |
      SELECT ?s ?o
      WHERE { ?s %PREDICATE_LARGE_1% ?o }
      LIMIT 1000
  - name: result-size-medium
    description: Export 100K tuples
    group: result-size
    query: |
      SELECT ?s ?o
      WHERE { ?s %PREDICATE_LARGE_1% ?o }
      LIMIT 100000
  - name: result-size-large
    description: Export 1M tuples
    group: result-size
    query: |
      SELECT ?s ?o
      WHERE { ?s %PREDICATE_LARGE_1% ?o }
      LIMIT 1000000
  - name: result-size-xlarge
    description: Export 10M tuples
    group: result-size
    query: |
      SELECT ?s ?o
      WHERE { ?s %PREDICATE_LARGE_1% ?o }
      LIMIT 10000000
  
  # # Full scans
  # - name: full-scan-constrained # TODO
  #   description: x
  #   group: full-scan
  #   query: |
  #     SELECT (COUNT(*) AS ?count) { ?s ?p ?o }
  # - name: full-scan-filter
  #   description: x
  #   group: full-scan
  #   query: |
  #     SELECT (COUNT(*) AS ?count) {
  #       ?s ?p ?o . FILTER(?p != %PREDICATE_LARGE_1%) }

  # NUMERIC function queries.
  #
  # TODO: Add functionality to ignore the time for warmup queries (but execute them)
  # TODO: Add functionality to subtract time of baseline query. And note the aw
  #
  # TODO: functions
  # * Numeric unary functions (e.g., ABS, CEIL, FLOOR, ROUND)
  # * Numeric binary functions (e.g., +, -, *, /)
  # * String functions (e.g., STRLEN, SUBSTR, UCASE, LCASE)
  # * Date functions (e.g., NOW, YEAR, MONTH, DAY)
  # * Variadic functions (e.g., IF, COALESCE, CONCAT) 
  # * Expression with one function [chunked might make a difference]
  # * Expression with many functions [tests chunked vs. entry by entry evaluation]
  # * TODO: How to measure the time for the functions minus the time for computing the input?
  # * TODO: Find simple query, where the function or expression is the bottleneck
  # * IDEA: generate large inputs via VALUES (with Cartesian product) and BIND
  - name: numeric-predicate-warmup
    description: Warmup query for reading predicate
    group: numeric-function
    query: |
      SELECT (COUNT(*) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_WITH_NUMERIC% ?o }
  - name: numeric-baseline
    description: Baseline for numeric queries
    group: numeric-function
    query: |
      SELECT (SUM(?o) AS ?sum)
      WHERE { ?s %PREDICATE_LARGE_WITH_NUMERIC% ?o }
  - name: numeric-abs
    description: ABS function
    group: numeric-function
    query: |
      SELECT (SUM(ABS(?o)) AS ?sum)
      WHERE { ?s %PREDICATE_LARGE_WITH_NUMERIC% ?o }
  - name: numeric-ceil
    description: CEIL function
    group: numeric-function
    query: |
      SELECT (SUM(CEIL(?o)) AS ?sum)
      WHERE { ?s %PREDICATE_LARGE_WITH_NUMERIC% ?o }
  - name: numeric-floor
    description: FLOOR function
    group: numeric-function
    query: |
      SELECT (SUM(FLOOR(?o)) AS ?sum)
      WHERE { ?s %PREDICATE_LARGE_WITH_NUMERIC% ?o }
  - name: numeric-round
    description: ROUND function
    group: numeric-function
    query: |
      SELECT (SUM(ROUND(?o)) AS ?sum)
      WHERE { ?s %PREDICATE_LARGE_WITH_NUMERIC% ?o }
  - name: numeric-add
    description: Addition
    group: numeric-function
    query: |
      SELECT (SUM(?o + ?o) AS ?sum)
      WHERE { ?s %PREDICATE_LARGE_WITH_NUMERIC% ?o }
  - name: numeric-greater
    description: Greater than
    group: numeric-function
    query: |
      SELECT (SUM(?o > 0) AS ?sum)
      WHERE { ?s %PREDICATE_LARGE_WITH_NUMERIC% ?o }
  
  # Numeric (Binary Search) Filter
  - name: numeric-filter-bin-search
    description: todo
    group: filter
    query: |
      SELECT (COUNT(?s) AS ?count) {
        ?s %PREDICATE_LARGE_WITH_NUMERIC% ?o .
        FILTER (?o >= %AVG_PREDICATE_LARGE_WITH_NUMERIC%) }
  
  # Other Filters
  - name: filter-few-results
    description: todo
    group: filter
    query: |
      SELECT (COUNT(?s) AS ?count) {
        ?s %PREDICATE_LARGE_1% ?o . FILTER (?s = ?o) }
  - name: filter-many-results
    description: todo
    group: filter
    query: |
      SELECT (COUNT(?s) AS ?count) {
        ?s %PREDICATE_LARGE_1% ?o . FILTER (?s != ?o) }

  # DATE function queries (e.g., NOW, YEAR, MONTH, DAY)
  - name: date-predicate-warmup
    description: Warmup query for reading date predicate
    group: date-function
    query: |
      SELECT (COUNT(?o) AS ?count)
      WHERE { ?s %PREDICATE_LARGE_WITH_DATE% ?o }
  - name: date-baseline
    description: Baseline for date queries
    group: date-function
    query: |
      SELECT (SUM(?o = ?o) AS ?sum)
      WHERE { ?s %PREDICATE_LARGE_WITH_DATE% ?o }
  - name: date-year
    description: YEAR function
    group: date-function
    query: |
      SELECT (SUM(YEAR(?o)) AS ?sum)
      WHERE { ?s %PREDICATE_LARGE_WITH_DATE% ?o }
  - name: date-month
    description: MONTH function
    group: date-function
    query: |
      SELECT (SUM(MONTH(?o)) AS ?sum)
      WHERE { ?s %PREDICATE_LARGE_WITH_DATE% ?o }
  - name: date-day
    description: DAY function
    group: date-function
    query: |
      SELECT (SUM(DAY(?o)) AS ?sum)
      WHERE { ?s %PREDICATE_LARGE_WITH_DATE% ?o }
  - name: date-now
    description: NOW function
    group: date-function
    query: |
      SELECT (SUM(NOW()) AS ?sum)
      WHERE { ?s %PREDICATE_LARGE_WITH_DATE% ?o }

  # STATISTICS queries.
  - name: number-of-triples
    description: Total number of triples
    group: statistics
    query: |
      SELECT (COUNT(?s) AS ?count)
      WHERE { ?s ?p ?o }
  - name: number-of-subjects
    description: Total number of distinct subjects
    group: statistics
    query: |
      SELECT (COUNT(DISTINCT ?s) AS ?count)
      WHERE { ?s ?p ?o }
  - name: number-of-predicates
    description: Total number of distinct predicates
    group: statistics
    query: |
      SELECT (COUNT(DISTINCT ?p) AS ?count)
      WHERE { ?s ?p ?o }
  - name: number-of-objects
    description: Total number of distinct objects
    group: statistics
    query: |
      SELECT (COUNT(DISTINCT ?o) AS ?count)
      WHERE { ?s ?p ?o }
  - name: number-of-literals
    description: Total number of literals
    group: statistics
    query: |
      SELECT (COUNT(?o) AS ?count)
      WHERE { ?s ?p ?o FILTER ISLITERAL(?o) }
  - name: number-of-blank-nodes
    description: Total number of blank nodes
    group: statistics
    query: |
      SELECT (COUNT(?s) AS ?count)
      WHERE { ?s ?p ?o FILTER ISBLANK(?s) }
  # TODO: add queries
  # ORDER BY
  # * large predicate + order by
  #
  # JOINS
  # * join large predicates, small result
  # * join large predicates, medium result
  # * join large predicates, large result
  # * star joins
  # * chain joins
  #
  # SPECIAL JOINS
  # * optional join
  # * minus join
  # * multi-column join
  # * union
  #
  # LANGUAGE FILTER
  # * rdfs:label und FILTER(LANG(?o) = "en")
  # * rdfs:label und FILTER(LANGMATCHES(LANG(?o), "en"))
  # * rdfs:label und FILTER(LANG(?o) != "en")  [no optimization]
  # * rdfs:label und FILTER(LANG(?o) IN ("en", "de"))
  #
  # EXPRESSIONS
  # * Large predicate with binary FILTER expression
  # * All sorts of functions
  #
  # GRAPHS
  # * check that graph filters work efficiently
  #
  #
  # SELECT ?p1 ?p2 (COUNT(?m) AS ?count) WHERE {
  #   ?s ?p1 ?m .
  #   ?m ?p2 ?o .
  # }
  # GROUP BY ?p1 ?p2
  # ORDER BY DESC(?count)
  #
